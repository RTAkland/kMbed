package io.karma.kmbed.gradle

import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import java.io.ByteArrayOutputStream
import java.io.File
import java.nio.file.Path
import java.nio.file.StandardOpenOption
import java.util.zip.DeflaterOutputStream
import kotlin.io.path.ExperimentalPathApi
import kotlin.io.path.deleteIfExists
import kotlin.io.path.div
import kotlin.io.path.fileSize
import kotlin.io.path.outputStream
import kotlin.io.path.readBytes
import kotlin.io.path.relativeTo
import kotlin.io.path.walk

/**
 * @author Alexander Hinze
 * @since 07/11/2024
 */
abstract class KmbedGenerateSourcesTask : DefaultTask() {
    companion object {
        private val fieldNameReplacePattern: Regex = Regex("""[/\\=:.]""")
    }

    @get:InputFiles
    abstract val resourceDirectories: ConfigurableFileCollection

    @get:OutputDirectory
    abstract val sourceDirectory: DirectoryProperty

    private val extension = project.extensions.getByType(KmbedProjectExtension::class.java)

    @OptIn(ExperimentalPathApi::class)
    @TaskAction
    fun invoke() {
        for (resourceDir in resourceDirectories) {
            val resourceRoot = resourceDir.toPath()
            logger.info("Processing resources in $resourceRoot")
            for (path in resourceRoot.walk()) {
                generateSources(path, resourceRoot)
            }
        }
    }

    private fun getGlobalData(path: Path): ByteArray {
        // Zlib compression is only really effective for file sizes larger than ~256 bytes
        if (!extension.compression || path.fileSize() < extension.compressionThreshold) {
            return path.readBytes()
        }
        return ByteArrayOutputStream().use { bos ->
            DeflaterOutputStream(bos).use { dos ->
                dos.write(path.readBytes())
            }
            bos.toByteArray()
        }
    }

    private fun String.chunkedOnNextSpace(length: Int): List<String> {
        val words = split(" ")
        val lines = ArrayList<String>()
        var currentLine = StringBuilder()
        for (word in words) {
            // If adding the word exceeds the line length, start a new line
            if (currentLine.length + word.length + (if (currentLine.isNotEmpty()) 1 else 0) > length) {
                lines.add(currentLine.toString())
                currentLine = StringBuilder(word)
                continue
            }
            // If it fits, add the word to the current line
            if (currentLine.isNotEmpty()) {
                currentLine.append(" ")
            }
            currentLine.append(word)
        }
        // Add the last line if it's not empty
        if (currentLine.isNotEmpty()) {
            lines.add(currentLine.toString())
        }
        return lines
    }

    @OptIn(ExperimentalStdlibApi::class)
    private fun generateSources(resourcePath: Path, resourceRoot: Path): File {
        val relativePath = resourcePath.relativeTo(resourceRoot)
        val fileName = relativePath.fileName.toString()
        val sourceFileName = fileName.substringBeforeLast(".")
        val parentPath = relativePath.parent

        val sourceBasePath = if (parentPath != null) sourceDirectory.get().asFile.toPath() / parentPath
        else sourceDirectory.get().asFile.toPath()

        val sourcePath = sourceBasePath / "$sourceFileName.kt"
        // @formatter:off
        val packageName = if(parentPath != null) "io.karma.kmbed.generated.${parentPath.toString()
            .lowercase()
            .replace(File.separator, ".")}"
        else "io.karma.kmbed.generated"
        // @formatter:on

        logger.info("Processing resource $resourcePath into $sourcePath")

        // Generate a new C/C++ resource header which forces the data into the .data section of the binary
        val fieldData = getGlobalData(resourcePath)
        val fieldName = relativePath.toString().replace(fieldNameReplacePattern, "_")
        val source = SourceBuilder().apply {
            line("""// Generated by the KMbed resource compiler ${BuildInfo.VERSION}""")
            line("""// !!! DO NOT EDIT THIS FILE BY HAND !!!""")
            newline()
            line("""package $packageName""")
            newline()
            line("""val __kmbed_$fieldName: UByteArray = ubyteArrayOf(""")
            pushIndent()
            // @formatter:off
            fieldData.joinToString(", ") { "0x${it.toHexString().uppercase()}U" }
                .chunkedOnNextSpace(100)
                .forEach(::line)
            // @formatter:on
            popIndent()
            line(""")""")
        }

        // Write out the new source file and update the entry's hash in the cache
        sourcePath.deleteIfExists()
        sourcePath.outputStream(StandardOpenOption.CREATE).bufferedWriter().use {
            it.write(source.render())
            it.flush()
        }

        return sourcePath.toFile()
    }
}