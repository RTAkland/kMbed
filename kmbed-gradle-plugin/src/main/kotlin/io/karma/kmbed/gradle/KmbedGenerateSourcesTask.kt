package io.karma.kmbed.gradle

import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import java.io.ByteArrayOutputStream
import java.io.File
import java.nio.file.Path
import java.nio.file.StandardOpenOption
import java.util.zip.DeflaterOutputStream
import kotlin.io.path.ExperimentalPathApi
import kotlin.io.path.createDirectories
import kotlin.io.path.deleteIfExists
import kotlin.io.path.div
import kotlin.io.path.fileSize
import kotlin.io.path.outputStream
import kotlin.io.path.readBytes
import kotlin.io.path.relativeTo
import kotlin.io.path.walk

/**
 * @author Alexander Hinze
 * @since 07/11/2024
 */
abstract class KmbedGenerateSourcesTask : DefaultTask() {
    companion object {
        private val fieldNameReplacePattern: Regex = Regex("""[/\\=:.\s]""")
    }

    @get:InputFiles
    abstract val resourceDirectories: ConfigurableFileCollection

    @get:OutputDirectory
    abstract val sourceDirectory: DirectoryProperty

    private val extension = project.extensions.getByType(KmbedProjectExtension::class.java)

    @OptIn(ExperimentalPathApi::class)
    @TaskAction
    fun invoke() {
        val resources = HashMap<Path, ResourceInfo>()
        for (resourceDir in resourceDirectories) {
            val resourceRoot = resourceDir.toPath()
            logger.info("Processing resources in $resourceRoot")
            for (path in resourceRoot.walk()) {
                generateSources(path, resourceRoot, resources)
            }
        }
        generateIndexSources(resources)
    }

    private fun getGlobalData(path: Path): Pair<ByteArray, Int> {
        if (!extension.compression || path.fileSize() < extension.compressionThreshold) {
            val data = path.readBytes()
            logger.info("Using uncompressed resource $path with ${data.size} bytes")
            return Pair(data, data.size)
        }
        val data = path.readBytes()
        return ByteArrayOutputStream().use { bos ->
            DeflaterOutputStream(bos).use { dos ->
                dos.write(data)
            }
            val compressedData = bos.toByteArray()
            val size = data.size
            val compressedSize = compressedData.size
            val percentage = ((size.toDouble() - compressedSize.toDouble()) / size.toDouble()) * 100.0
            logger.info("Compressed resource $path from $size to $compressedSize bytes ($percentage%)")
            Pair(compressedData, size)
        }
    }

    private fun String.chunkedOnNextSpace(length: Int): List<String> {
        val words = split(" ")
        val lines = ArrayList<String>()
        var currentLine = StringBuilder()
        for (word in words) {
            // If adding the word exceeds the line length, start a new line
            if (currentLine.length + word.length + (if (currentLine.isNotEmpty()) 1 else 0) > length) {
                lines.add(currentLine.toString())
                currentLine = StringBuilder(word)
                continue
            }
            // If it fits, add the word to the current line
            if (currentLine.isNotEmpty()) {
                currentLine.append(" ")
            }
            currentLine.append(word)
        }
        // Add the last line if it's not empty
        if (currentLine.isNotEmpty()) {
            lines.add(currentLine.toString())
        }
        return lines
    }

    private fun generateIndexSources(resources: HashMap<Path, ResourceInfo>) {
        val sourcePath = sourceDirectory.get().asFile.toPath() / "__kmbed_resources.kt"
        logger.info("Generating resource index into $sourcePath")

        val source = SourceBuilder().apply {
            line("""// Generated by the KMbed resource compiler ${BuildInfo.VERSION}""")
            line("""// !!! DO NOT EDIT THIS FILE BY HAND !!!""")

            newline()

            line("""package ${extension.resourceNamespace}""")

            newline()

            line("""import io.karma.kmbed.runtime.AbstractResources""")
            line("""import io.karma.kmbed.runtime.GeneratedKmbedApi""")
            line("""import kotlinx.cinterop.staticCFunction""")
            line("""import platform.posix.atexit""")

            newline()

            line("""@OptIn(GeneratedKmbedApi::class)""")
            line("""object Resources : AbstractResources() {""")
            pushIndent()
            line("""init {""")
            pushIndent()
            for ((path, resourceInfo) in resources) {
                val (_, fqn, _, uncompressedSize) = resourceInfo
                line("""add("$path", $fqn, $uncompressedSize)""")
            }
            line("""// @formatter:off""")
            line("""atexit(staticCFunction<Unit> { Resources.cleanup() })""")
            line("""// @formatter:on""")
            popIndent()
            line("""}""")
            popIndent()
            line("""}""")

            newline()

            line("""actual val R: AbstractResources""")
            line("""    get() = Resources""")
        }

        // Write out the new source file and update the entry's hash in the cache
        sourcePath.deleteIfExists()
        sourcePath.parent?.createDirectories()
        sourcePath.outputStream(StandardOpenOption.CREATE).bufferedWriter().use {
            it.write(source.render())
            it.flush()
        }
    }

    @OptIn(ExperimentalStdlibApi::class)
    private fun generateSources(resourcePath: Path, resourceRoot: Path, resources: HashMap<Path, ResourceInfo>) {
        val relativePath = resourcePath.relativeTo(resourceRoot)
        val fileName = relativePath.fileName.toString()
        val sourceFileName = fileName.substringBeforeLast(".")
        val parentPath = relativePath.parent

        val packageName = parentPath?.let {
            "${extension.resourceNamespace}.rdata.${
                it.toString().lowercase().replace(File.separator, ".")
            }"
        } ?: "${extension.resourceNamespace}.rdata"

        val sourceDir = sourceDirectory.get().asFile.toPath()
        val sourceBasePath = parentPath?.let { sourceDir / it } ?: sourceDir
        val sourcePath = sourceBasePath / "$sourceFileName.kt"

        logger.info("Processing resource $resourcePath into $sourcePath")

        // Generate a new Kotlin source file
        val (fieldData, uncompressedSize) = getGlobalData(resourcePath)
        val fieldName = relativePath.toString().replace(fieldNameReplacePattern, "_")
        val source = SourceBuilder().apply {
            line("""// Generated by the KMbed resource compiler ${BuildInfo.VERSION}""")
            line("""// !!! DO NOT EDIT THIS FILE BY HAND !!!""")
            newline()
            line("""package $packageName""")
            newline()
            line("""import io.karma.kmbed.runtime.GeneratedKmbedApi""")
            newline()
            line("""@GeneratedKmbedApi""")
            line("""val __kmbed_$fieldName: UByteArray = ubyteArrayOf(""")
            pushIndent()
            // @formatter:off
            fieldData.joinToString(", ") { "0x${it.toHexString().uppercase()}U" }
                .chunkedOnNextSpace(100)
                .forEach(::line)
            // @formatter:on
            popIndent()
            line(""")""")
        }

        // Write out the new source file and update the entry's hash in the cache
        sourcePath.deleteIfExists()
        sourcePath.parent?.createDirectories()
        sourcePath.outputStream(StandardOpenOption.CREATE).bufferedWriter().use {
            it.write(source.render())
            it.flush()
        }

        relativePath.apply {
            require(this !in resources) { "Resource $resourcePath already exists" }
            resources[this] = ResourceInfo(
                fieldName, "$packageName.__kmbed_$fieldName", fieldData.size, uncompressedSize
            )
        }
    }
}